//
// Created by Cory Todd on 12/11/2020.
//
#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <string>
#include <vector>

namespace fs = std::filesystem;

/**
 * @class TestDetails
 * @brief Represents a test case
 */
class TestDetails {
 public:
  TestDetails(int id, const std::string& input, const std::string& expect, bool useArgs = false, bool callMain = false)
   : _id(id), _input(input), _expect(expect), _useArgs(useArgs), _callMain(callMain) {

  }

  //! Numeric id of test
  int getId() const { return _id; }

  //! Test input script
  const std::string& getInputPath() const {return _input; }

  //! Expected stdout of test script
  const std::string& getExpectPath() const {return _expect; }

  //! If true, provide "- arg1 arg2 arg3 arg4" to stdin
  bool useArgs() const { return _useArgs; }

  //! If true, use main() from provided script
  bool callMain() const { return _callMain; }

 private:
  const int _id;
  const std::string _input;
  const std::string _expect;
  const bool _useArgs;
  const bool _callMain;
};

using TestGrouping = std::map<int, std::vector<std::string>>;

//! Returns the id of this test which is extracted from the file name
int extract_id(const std::string& path) {
  // Look at just the filename (ignore the path)
  auto s = fs::path(path).filename().string();

  if(s.find("skip") != std::string::npos){
    return -1;
  }
  auto split = s.find('_');
  if(split == std::string::npos){
    return -1;
  }

  auto part = s.substr(0, split);
  return std::stoi(part);
}

//! Returns true if this file expects args via argc and argv
bool requires_args(const std::string& path) {
  auto s = fs::path(path).filename().string();
  return s.find("args") != std::string::npos;
}

//! Returns true if this file has executable code in its main() function
bool requires_main(const std::string& path) {
  auto s = fs::path(path).filename().string();
  return s.find("call_main") != std::string::npos;
}

//! Generate test details from the provided file groupings
std::vector<TestDetails> generate_details(const TestGrouping& grouping) {
  std::vector<TestDetails> result;

  for(const auto&g:grouping){

    auto id = g.first;

    // Missing expect or script
    if(g.second.size() < 2) {
      std::cout << "Missing files for test #" << id<< std::endl;
      continue;
    }

    // Identify the script and the expect
    std::string script(g.second[0]);
    std::string expect(g.second[1]);

    // make sure script and expect are in the right order
    if(expect.find("expect") == std::string::npos) {
      std::swap(expect, script);
    }

    // Avoid issues with escaped path separators
    std::replace(script.begin(), script.end(), '\\', '/');
    std::replace(expect.begin(), expect.end(), '\\', '/');

    auto useArgs = requires_args(script);
    auto callMain = requires_main(script);

    result.emplace_back(id, script, expect, useArgs, callMain);
  }

  return result;
}

//! Group all files by test id, recursively searches root and its subdirectories
void group_files(const fs::path& root, TestGrouping& grouping) {

  // Group all tests and their expected results
  for (const auto & entry : fs::directory_iterator(root)) {

    if(entry.path().empty()) {
      continue;
    }

    // Search folders recursively
    if(entry.is_directory()) {
      group_files(entry.path(), grouping);
      continue;
    }

    auto id = extract_id(entry.path().string());
    if(id == -1){
      continue;
    }

    // Make sure we use absolute paths in case the unit test structure changes
    auto fullPath = fs::absolute(entry.path()).string();

    // Add or update the file group
    if(grouping.find(id) == grouping.end()){
      grouping.insert({id, {fullPath}});
    } else {
      grouping[id].emplace_back(fullPath);
    }
  }
}

int main(int argc, char **argv) {

  // CMake should copy all the test data into our build tree
  std::string root = "../test/test_data";
  if(!fs::exists(root)) {
    throw std::runtime_error("test_data is missing!");
  }

  // Iterate over all the files and group them by id#
  TestGrouping groupings;
  group_files(root, groupings);
  auto testDetails = generate_details(groupings);

  std::ofstream testh;
  testh.open("../test/GeneratedTests.hpp");
  testh << R"--(
// AUTOGENERATED - DO NOT EDIT
#pragma once
#include <map>

// script source, stdout expected, use args?, call main ?
using TestDetail = std::tuple<std::string, std::string, bool, bool>;

namespace test_details {
    const std::map<int, TestDetail> AllTestDetails = {
)--";
  for(const auto& test : testDetails) {
    testh << "\t\tstd::make_pair<int, TestDetail>(" << test.getId()
          << ", std::make_tuple<std::string, std::string, bool, bool>(" << std::endl
          << "\"" << test.getInputPath() << "\"," << std::endl
          << "\"" << test.getExpectPath() << "\","
          << " " << (test.useArgs() ? "true" : "false") << " ,"
          << " " << (test.callMain() ? "true" : "false") << " ))," << std::endl;
  }

  testh << "};" << std::endl << "} // end namespace test_details" << std::endl;
  testh.close();

  return 0;
}
