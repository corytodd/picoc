//
// Created by Cory Todd on 12/11/2020.
//
#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <string>
#include <vector>

namespace fs = std::filesystem;

using FileMap = std::map<int, std::vector<std::string>>;

int extract_id(const fs::path& path) {
  auto s = path.filename().string();
  auto split = s.find('_');
  if(split == std::string::npos){
    return -1;
  }

  auto part = s.substr(0, split);
  return std::stoi(part);
}

void iterate_directory(const fs::path& root, FileMap& fileMap) {
  for (const auto & entry : fs::directory_iterator(root)) {

    if(entry.path().empty()) {
      continue;
    }

    if(entry.is_directory()) {
      iterate_directory(entry.path(), fileMap);
      continue;
    }

    auto id = extract_id(entry.path().filename());
    if(id == -1){
      continue;
    }

    auto fullPath = fs::absolute(entry.path());

    auto it = fileMap.find(id);
    if(it == fileMap.end()){
      fileMap.insert(std::pair<int, std::vector<std::string>>(id, {fullPath.string()}));
    } else {
      fileMap[id].emplace_back(fullPath.string());
    }
  }
}

int main(int argc, char **argv) {

  // CMake should copy all the test data into our build tree
  std::string root = "../test/test_data";
  if(!fs::exists(root)) {
    throw std::runtime_error("test_data is missing!");
  }

  // Iterate over all the files and group them by id#
  FileMap mapped;

  iterate_directory(root, mapped);

  std::ofstream testh;
  testh.open("../test/GeneratedTests.hpp");
  testh << R"--(
// AUTOGENERATED - DO NOT EDIT
#pragma once
#include <map>
using StPair = std::pair<std::string, std::string>;

namespace test_details {
    const std::map<int, StPair> test_paths = {
)--";
  for(const auto& pair : mapped){

    if(pair.second.size() < 2){
      std::cout << "Missing files for " << pair.first << std::endl;
      continue;
    }
    std::string script(pair.second[0]);
    std::string expect(pair.second[1]);

    // make sure script and expect are in the right order
    if(expect.find("expect") == std::string::npos) {
      std::swap(expect, script);
    }

    // Avoid issues with escaped path separators
    std::replace(script.begin(), script.end(), '\\', '/');
    std::replace(expect.begin(), expect.end(), '\\', '/');

    testh << "\t\tstd::make_pair<int, StPair>(" << pair.first
          << ", std::make_pair<std::string, std::string>(" << std::endl
          << "\"" << script << "\"," << std::endl
          << "\"" << expect << "\"))," << std::endl;

  }

  testh << "};" << std::endl << "} // end namespace test_details" << std::endl;
  testh.close();

  return 0;
}
